<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Random 2048</title>


<link rel="stylesheet" type="text/css" href="../../../stylesheets/blog.css">

<!-- Styles for R syntax highlighter -->
<link rel="stylesheet" type="text/css" href="../../../stylesheets/blog2.css">

    <link rel="stylesheet" type="text/css" href="../../../stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../../stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../../stylesheets/print.css" media="print" />

<!-- R syntax highlighter -->
<script src="../../../javascripts/r.js"></script>


</head>

<body>

<div class="container">


    <header>
      <div class="container">
        <a href="http://darrkj.github.io/blogs" class="btn">Blogs</a>
        <h1>Random 2048</h1>
        <h2></h2>

<h4 class="author"><em>Kenny Darrell</em></h4>
<h4 class="date"><em>Feb 22, 2015</em></h4>
        </section>
      </div>
    </header>





<p>Have you ever played 2048? About a year ago, last winter, I became extremely interested in this game. All sorts of posts on Hacker News had new implementations of the game. Some that merely changed the numbers to <a href="http://doge2048.com/">images</a> all the way to those that had there own unique <a href="http://cesarkawakami.github.io/2048-5D/">method</a>. You can find a ton of them <a href="http://get2048.com/">here</a>. There is even a <a href="https://www.udacity.com/course/ud248">course</a> on <a href="https://www.udacity.com/">Udacity</a> that teaches you how to build your own version.</p>
<p>I was able to beat it many times and got close to 4098 a few times. I really became interested in what was the best strategy to use. Many people created AI to play perfectly. Another created a hard version where it gave you the worst possible outcome on every move. I started thinking how good is randomly hitting directions. I could not find one that had an API to feed random directions into so I coded my own. I think now there may be but I did this a few months ago and just wanted to write about it.</p>
<p>You can get my implementation by running the following in R.</p>
<pre class="r"><code>devtools::source_url('https://raw.githubusercontent.com/darrkj/darrkj.github.io/master/rcode/r2048.R')</code></pre>
<pre><code>## SHA-1 hash of file is bb990681619d5e7dc3928fd77345347cea459d0a</code></pre>

<p>We can play the game in the R console as can be seen below. I thought about making an app to let you play it from either Shiny or R-Fiddle. It looks pretty bad though as I only made it playable for testing the game logic.</p>


<pre><code>play(gen_board())
  .    .    .    .  
  .    .    .    .  
  .    2    .    .  
  2    .    .    .  
1: 'd'
  .    .    .    .  
  .    .    .    .  
  .    .    .    2  
  2    2    .    .  
1: 'l'
  .    .    .    .  
  .    .    .    2  
  2    .    .    .  
  4    .    .    .  
1: 
</code></pre>


<p>The real way to use this is by simulating a game, or a large number of games. With this you can feed a strategy to play the game. So it is really meant more as a harness around the game. Now we can simulate an entire game by running the following.</p>
<pre class="r"><code>auto_play()</code></pre>
<pre><code>##   board_sum max moves log_sum depth
## 1       308 128   153      47     7</code></pre>

<p>This shows us the following information:</p>
<ol style="list-style-type: decimal">
<li>board_sum - The sum of all of the tiles on the board, this is directly related to the score in the official version of the game. That score is generated by every move that merges two cells, adding the merged value 2 onto 2 =&gt; 4. It is much smaller though as it only counts the final value instead of every merge to reach it. The only difference is there are some random insert of a 4, this 4 was never merged to get a score so it is not a perfect mapping.</li>
<li>max - This is the max cell attained in this round of play. No surprise here that it is not 2014 or that it is really not that high.</li>
<li>moves - Also pretty self explanatory, the number of moves it took to reach the end game state.</li>
<li>log_sum - Doing statistics on collections of the outputs is odd because of the growth rate. Since everything is a different integer in the 2^x calculation we can take the log with base two to get a better representation for statistical purposes.</li>
<li>depth - This is the log base of the highest cell. So instead of going from 128 to 256 it will be 7 to 8. Much better for means and variances of of lots of runs.</li>
</ol>
<p>By default this is going to use a uniform distribution on each move, so it is just as likely to swipe up as down, left or right. I am just going to run this a lot of times and see what the outcome is.</p>
<pre class="r"><code>runs &lt;- 10000

a &lt;- c()
for (i in seq(runs)) {
  a &lt;- rbind(a, auto_play())
}

table(a$depth)</code></pre>
<pre><code>## 
##    4    5    6    7    8    9 
##   21  578 3473 4967  959    2</code></pre>
<pre class="r"><code>mean(a$log_sum)</code></pre>
<pre><code>## [1] 45.5996</code></pre>
<pre class="r"><code>sd(a$log_sum)</code></pre>
<pre><code>## [1] 3.729567</code></pre>
<p>After thinking quite a bit about how I play the game it turns out it could almost be coded as a random distribution like this. I use a very simple strategy that chooses two directions more often than the other two. It does not matter which two directions as long as they are not opposite, no left and right but you can use either left and up or left and down. This seemed to be very effective. This makes the numbers on the tiles monotonically increasing as you move in the direction of your likely moves.</p>
<p>Since it is easy to give this as an input we can see how much better it performs than the uniform method. I would not think that it would be getting many 2048 tiles because some of the moves are more thought out, in the scenario of left and down I will go up at very specific points not at all random.</p>
<pre class="r"><code>b &lt;- c()
for (i in seq(runs)) {
  b &lt;- rbind(b, auto_play(c(.45, .001, .099, .45)))
}

table(b$depth)</code></pre>
<pre><code>## 
##    4    5    6    7    8    9   10 
##    2  188 1847 5006 2772  184    1</code></pre>
<pre class="r"><code>mean(b$log_sum)</code></pre>
<pre><code>## [1] 54.0733</code></pre>
<pre class="r"><code>sd(b$log_sum)</code></pre>
<pre><code>## [1] 4.911531</code></pre>
<p>We can see from the output that this is better. We can make a more rigorous statement though and see the statistical significance of the non-uniform over the uniform.</p>
<pre class="r"><code>t.test(b$log_sum, a$log_sum, alternative = 'greater')</code></pre>
<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  b$log_sum and a$log_sum
## t = 137.4023, df = 18652.84, p-value &lt; 2.2e-16
## alternative hypothesis: true difference in means is greater than 0
## 95 percent confidence interval:
##  8.372256      Inf
## sample estimates:
## mean of x mean of y 
##   54.0733   45.5996</code></pre>
<p>I have any more interesting ideas I want to try with this setup but I wanted to get this out first in case my interest fades and I never get back to it.</p>






<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with --self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

