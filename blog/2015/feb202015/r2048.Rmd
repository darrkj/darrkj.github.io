---
title: '2048'
author: "Kenny Darrell"
date: "July 1, 2014"
output: html_document
---

Have you ever played 2048? About a year ago, last winter, I became extremely interested in this game. All sorts of posts on Hacker News had new implementations of the game. Some that mearly changed the numbers to [images](http://doge2048.com/) all the way to those that had there own unique [method](http://cesarkawakami.github.io/2048-5D/). You can find a ton of them [here](http://get2048.com/). There is even a [course](https://www.udacity.com/course/ud248) on [Udacity](https://www.udacity.com/) that teaches you how to build your own version.

I was able to beat it many times and got close to 4098 a few times. I really became interested in what was the best stratagy to use. Many people created AI to play perfectly. Another created a hard version where it gave you the worst possible outcome on every move. I started thinking how good is randomly hitting directions. I could not find one that had an API to feed random directions into so I coded my own. I think now there may be but I did this a few months ago and just wanted to write about it.

You can get my implentation by running the following in R.

```{r}
devtools::source_url('http://darrkj.github.io/rcode/r2048.R')

```

Now we can simulate an entire game by running the following.

```{r}
auto_play()
```

By defualt this is going to use a uniform distribution on each move, so it is just as likely to swipe up as down, left or right. I am just going to run this a lot of times and see what the outcome is. 

```{r, cache=TRUE}
runs <- 10000

a <- c()
for (i in seq(runs)) {
  if (i %% 50 == 0) print(i)
  a <- rbind(a, auto_play())
}

table(a$depth)
mean(a$board_sum)
var(a$board_sum)
mean(a$moves)
mean(a$log_sum)
sd(a$log_sum)
```

I am using a very simple stratagy that chooses two directions more often than the other two. This seemed to be very effective. One method is uniform over the directions. There is also a very you cna play in the console but it is very ugly.

```{r}
b <- c()
for (i in seq(runs)) {
  if (i %% 50 == 0) print(i)      
  b <- rbind(b, auto_play(c(.45, .001, .099, .45)))
}

table(b$depth)
mean(b$board_sum)
var(b$board_sum)
mean(b$moves)
mean(b$log_sum)
sd(b$log_sum)
```




There is a statistical significance that the non uniform method is better.

```{r}
t.test(b$log_sum, a$log_sum, alternative = 'greater')
```

Is there an optimal random swipe distribution.

We could make a hill clombing algorithm.


```{r}
input_dist <- c(.45, .0001, .0099, .45)

max_2048 <- function(input_dist) {
  results <- auto_play(input_dist)
  for (i in seq(runs)) {
    if (nrow(results) %% 50 == 0) print(nrow(results))      
    results <- rbind(results, auto_play(input_dist))
  }
  mean(results$log_sum)
}





table(b$depth)
mean(b$board_sum)
var(b$board_sum)
mean(b$moves)
mean(b$log_sum)
sd(b$log_sum)

}
```




```












```{r}
c <- c()
for (i in seq(runs)) {
  if (i %% 50 == 0) print(i)      
  c <- rbind(c, auto_play(c(.45, .0001, .0099, .45)))
}
c <- as.data.frame(c)
c$depth <- log2(c$max)

table(c$depth)
mean(c$board_sum)
var(c$board_sum)
mean(c$moves)
```



