<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Getting Side-tracked while palying with Basketball data</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Getting Side-tracked while palying with Basketball data</h1>

<p>It&#39;s March so basketball is all the rage. I was interested in analyzing some data and I was able to find NBA data to be the most accessible.  The data can be downloaded from
<a href="http://www.basketballgeek.com/data/">http://www.basketballgeek.com/data/</a>. Download the &ldquo;2008-2009 Regular Season:&rdquo; zip file. Unzip this and move the contents to a folder.</p>

<pre><code class="r"># Load packages used.
library(rbenchmark)
library(plyr)

# This is useful for importing data.
options(stringsAsFactors = FALSE)

# Create dir for data files.
dir &lt;- &quot;BBdata&quot;
dir.create(dir)
</code></pre>

<pre><code>## Warning: &#39;BBdata&#39; already exists
</code></pre>

<pre><code class="r">temp &lt;- tempfile()

# Location of the files.
url1 &lt;- &quot;http://www.basketballgeek.com/downloads/2008-2009.regular_season.zip&quot;

# Take the base of the file name at this loaction.
file &lt;- basename(url1)

# Download the file from the internet.
download.file(url1, file)

# Extract zipped contents to directory.
unzip(file, exdir = dir)

# The list of unzipped files.
fileList &lt;- list.files(dir)

# Only the csv data files.
fileList &lt;- fileList[grep(pattern = &quot;csv&quot;, x = fileList)]

# Full location to the files.
fileList &lt;- paste(dir, fileList, sep = &quot;/&quot;)

# Subset for faster running.
files &lt;- fileList[1:100]
</code></pre>

<p>I wanted to explore this data and just create some plots with it.  I tried to load each file and append it to a growing data set.  I knew this would be slow but I was in no rush.  I was not aware that it would take as long as it did though.  You will see later just how slow.  </p>

<p>Wrapping this in a function is just used for benchmarking and profiling, it is an easy way to take imperative line by line instructions and call them without copy and paste.</p>

<pre><code class="r"># Method which uses naive appending via rbind.
M1 &lt;- function() {
    # Use rbind to append each file to the first.
    games &lt;- read.csv(files[1], na.strings = &quot;&quot;)
    # Drop first that was already loaded.
    file &lt;- files[-1]
    # Loop over each file and append it to growing list.
    for (i in file) {
        tmpGame &lt;- read.csv(i, na.strings = &quot;&quot;)
        games &lt;- rbind(games, tmpGame)
    }
    return(games)
}
files &lt;- fileList[1:100]
Rprof(&quot;loop_rbind.out&quot;)
games1 &lt;- M1()
Rprof(NULL)
summaryRprof(&quot;loop_rbind.out&quot;)[c(2, 4)]
</code></pre>

<pre><code>## $by.total
##                       total.time total.pct self.time self.pct
## &lt;Anonymous&gt;                 8.84    100.00      0.02     0.23
## block_exec                  8.84    100.00      0.00     0.00
## call_block                  8.84    100.00      0.00     0.00
## doTryCatch                  8.84    100.00      0.00     0.00
## eval                        8.84    100.00      0.00     0.00
## evaluate                    8.84    100.00      0.00     0.00
## evaluate_call               8.84    100.00      0.00     0.00
## handle                      8.84    100.00      0.00     0.00
## in_dir                      8.84    100.00      0.00     0.00
## knit                        8.84    100.00      0.00     0.00
## M1                          8.84    100.00      0.00     0.00
## process_file                8.84    100.00      0.00     0.00
## process_group.block         8.84    100.00      0.00     0.00
## try                         8.84    100.00      0.00     0.00
## tryCatch                    8.84    100.00      0.00     0.00
## tryCatchList                8.84    100.00      0.00     0.00
## tryCatchOne                 8.84    100.00      0.00     0.00
## withCallingHandlers         8.84    100.00      0.00     0.00
## withVisible                 8.84    100.00      0.00     0.00
## rbind                       7.82     88.46      7.42    83.94
## read.table                  1.02     11.54      0.04     0.45
## read.csv                    1.02     11.54      0.00     0.00
## scan                        0.92     10.41      0.92    10.41
## anyDuplicated.default       0.28      3.17      0.28     3.17
## anyDuplicated               0.28      3.17      0.00     0.00
## [[.data.frame               0.06      0.68      0.04     0.45
## [[                          0.06      0.68      0.00     0.00
## type.convert                0.04      0.45      0.04     0.45
## unlist                      0.04      0.45      0.04     0.45
## file                        0.02      0.23      0.02     0.23
## is.factor                   0.02      0.23      0.02     0.23
## 
## $sampling.time
## [1] 8.84
</code></pre>

<p>This method is very bad.  I may want to pull more seasons that just 2008-2009 which will make it even worse.  Most everywhere you look in relation to making something in R work faster you see vectorization for math operations and pre-allocation for data storage operations.  Lets see how much this helps with the task at hand.</p>

<pre><code class="r"># This is a very handy data frame initialization function that I made and
# can clean up the look of preallocation when dealing with wide data
# frames.  You don&#39;t have to be as verbose with listing out every
# variable.
initDF &lt;- function(name, row) {
    # String which start the data frame istantiation.
    init &lt;- &quot;df &lt;- data.frame(&quot;
    for (i in name) {
        init &lt;- paste(init, i, &quot; = rep(NA, &quot;, row, &quot;), &quot;, sep = &quot;&quot;)
    }
    init &lt;- substr(init, 1, nchar(init) - 2)
    init &lt;- paste(init, &quot;)&quot;, sep = &quot;&quot;)
    eval(parse(text = init))
    return(df)
}

# Method which uses preallocation.
M2 &lt;- function() {
    # Read first file to get names in the data.
    game &lt;- read.csv(files[1], na.strings = &quot;&quot;)
    # The number of rows in the data.
    rows &lt;- nrow(game)
    # Its hard to know this exactly before hand so be conservative with guess.
    estRows &lt;- ceiling(rows * 1.5)
    # Preallocate the data frame.
    games &lt;- initDF(names(game), estRows)
    # Initialize index.
    j &lt;- 1
    # Loop over each file.
    for (i in files) {
        game &lt;- read.csv(i, na.strings = &quot;&quot;)
        # How many rows are in this data set.
        len &lt;- nrow(game)
        # Insert these rows into there spots in the preallocated data frame.
        games[j:(j + len - 1), ] &lt;- game
        # Increment the index
        j &lt;- j + len
    }
    # Remove the exccess from our conservative quess.
    games &lt;- games[1:(j - 1), ]
    return(games)
}
files &lt;- fileList[1:100]
Rprof(&quot;preallocation.out&quot;)
games2 &lt;- M2()
Rprof(NULL)
summaryRprof(&quot;preallocation.out&quot;)[c(2, 4)]
</code></pre>

<pre><code>## $by.total
##                     total.time total.pct self.time self.pct
## M2                        6.90    100.00      1.22    17.68
## &lt;Anonymous&gt;               6.90    100.00      0.00     0.00
## block_exec                6.90    100.00      0.00     0.00
## call_block                6.90    100.00      0.00     0.00
## doTryCatch                6.90    100.00      0.00     0.00
## eval                      6.90    100.00      0.00     0.00
## evaluate                  6.90    100.00      0.00     0.00
## evaluate_call             6.90    100.00      0.00     0.00
## handle                    6.90    100.00      0.00     0.00
## in_dir                    6.90    100.00      0.00     0.00
## knit                      6.90    100.00      0.00     0.00
## process_file              6.90    100.00      0.00     0.00
## process_group.block       6.90    100.00      0.00     0.00
## try                       6.90    100.00      0.00     0.00
## tryCatch                  6.90    100.00      0.00     0.00
## tryCatchList              6.90    100.00      0.00     0.00
## tryCatchOne               6.90    100.00      0.00     0.00
## withCallingHandlers       6.90    100.00      0.00     0.00
## withVisible               6.90    100.00      0.00     0.00
## [&lt;-.data.frame            4.52     65.51      1.06    15.36
## [&lt;-                       4.52     65.51      0.00     0.00
## xpdrows.data.frame        3.24     46.96      3.24    46.96
## read.table                1.10     15.94      0.04     0.58
## read.csv                  1.10     15.94      0.00     0.00
## scan                      1.00     14.49      1.00    14.49
## match                     0.22      3.19      0.22     3.19
## [.data.frame              0.06      0.87      0.04     0.58
## [                         0.06      0.87      0.00     0.00
## type.convert              0.04      0.58      0.04     0.58
## %in%                      0.02      0.29      0.02     0.29
## lapply                    0.02      0.29      0.02     0.29
## [[                        0.02      0.29      0.00     0.00
## [[.data.frame             0.02      0.29      0.00     0.00
## sapply                    0.02      0.29      0.00     0.00
## 
## $sampling.time
## [1] 6.9
</code></pre>

<p>The first thing I notice here is that I have to make a guess on the size of the data, which may not always be easy. Here I got lucky in that I have already done the operation once so I know exactly how many rows I need.  To make it more realistic I was a little conservative and applied a fudge factor.  The next problem is the code is odd in respect to the hoops you jump through to index correctly, to not overwrite old data or leave gaps in between appended sets.  We did save some time though, not much but it does go faster.  Was it worth it though, dealing with the indexing maze in order to gain a small speed improvement.</p>

<p>It appears there has been some discussion about this type of data wrangling.  There is a better way to use rbind, via do.call.
<a href="http://r.789695.n4.nabble.com/Concatenating-data-frame-td799749.html">http://r.789695.n4.nabble.com/Concatenating-data-frame-td799749.html</a>
This gives me another method to look into. </p>

<pre><code class="r">
# Method which uses do.call, rbind all at once.
M3 &lt;- function() {
    # Initialize list that will store each loaded file.
    g &lt;- vector(&quot;list&quot;, length(files))
    # Initialize the index.
    j &lt;- 1
    # Loop over all of the files.
    for (i in files) {
        g[[j]] &lt;- read.csv(i, na.strings = &quot;&quot;)
        j &lt;- j + 1
    }
    games &lt;- do.call(&quot;rbind&quot;, g)
    return(games)
}
files &lt;- fileList[1:100]
Rprof(&quot;native.out&quot;)
games3 &lt;- M3()
Rprof(NULL)
summaryRprof(&quot;native.out&quot;)[c(2, 4)]
</code></pre>

<pre><code>## $by.total
##                       total.time total.pct self.time self.pct
## M3                          1.80    100.00      0.04     2.22
## &lt;Anonymous&gt;                 1.80    100.00      0.02     1.11
## block_exec                  1.80    100.00      0.00     0.00
## call_block                  1.80    100.00      0.00     0.00
## doTryCatch                  1.80    100.00      0.00     0.00
## eval                        1.80    100.00      0.00     0.00
## evaluate                    1.80    100.00      0.00     0.00
## evaluate_call               1.80    100.00      0.00     0.00
## handle                      1.80    100.00      0.00     0.00
## in_dir                      1.80    100.00      0.00     0.00
## knit                        1.80    100.00      0.00     0.00
## process_file                1.80    100.00      0.00     0.00
## process_group.block         1.80    100.00      0.00     0.00
## try                         1.80    100.00      0.00     0.00
## tryCatch                    1.80    100.00      0.00     0.00
## tryCatchList                1.80    100.00      0.00     0.00
## tryCatchOne                 1.80    100.00      0.00     0.00
## withCallingHandlers         1.80    100.00      0.00     0.00
## withVisible                 1.80    100.00      0.00     0.00
## read.table                  0.92     51.11      0.10     5.56
## read.csv                    0.92     51.11      0.00     0.00
## rbind                       0.84     46.67      0.78    43.33
## do.call                     0.84     46.67      0.00     0.00
## scan                        0.76     42.22      0.76    42.22
## type.convert                0.04      2.22      0.04     2.22
## [[                          0.04      2.22      0.00     0.00
## [[.data.frame               0.04      2.22      0.00     0.00
## %in%                        0.02      1.11      0.02     1.11
## anyDuplicated.default       0.02      1.11      0.02     1.11
## unlist                      0.02      1.11      0.02     1.11
## anyDuplicated               0.02      1.11      0.00     0.00
## sapply                      0.02      1.11      0.00     0.00
## simplify2array              0.02      1.11      0.00     0.00
## 
## $sampling.time
## [1] 1.8
</code></pre>

<p>Two things to note about the code itself; the size has reduced from the pre-allocation method and we have no indices to maintain.  But the best outcome is the speed, a good improvement.  I could probably live with this approach but I am intrigued by the another similar post and its recommendation to use rbind.fill from the plyr package.
<a href="http://r.789695.n4.nabble.com/Fast-dependable-way-to-quot-stack-together-quot-data-frames-from-a-list-td2532293.html">http://r.789695.n4.nabble.com/Fast-dependable-way-to-quot-stack-together-quot-data-frames-from-a-list-td2532293.html</a>
I have used this in the past when I have sets which may have different columns as it provides a nice feature of imputing them to missing instead of the error received from the regular rbind.  Lets give this a try.</p>

<pre><code class="r"># Method which uses plyr, references say it is the fastest approach.
M4 &lt;- function() {
    # Initialize list that will store each loaded file.
    g &lt;- vector(&quot;list&quot;, length(files))
    # Initialize the index.
    j &lt;- 1
    # Loop over all of the files.
    for (i in files) {
        g[[j]] &lt;- read.csv(i, na.strings = &quot;&quot;)
        j &lt;- j + 1
    }
    games &lt;- rbind.fill(g)
    return(games)
}
files &lt;- fileList[1:100]
Rprof(&quot;plyr.out&quot;)
games4 &lt;- M4()
Rprof(NULL)
summaryRprof(&quot;plyr.out&quot;)[c(2, 4)]
</code></pre>

<pre><code>## $by.total
##                     total.time total.pct self.time self.pct
## M4                        2.28    100.00      0.04     1.75
## &lt;Anonymous&gt;               2.28    100.00      0.02     0.88
## block_exec                2.28    100.00      0.00     0.00
## call_block                2.28    100.00      0.00     0.00
## doTryCatch                2.28    100.00      0.00     0.00
## eval                      2.28    100.00      0.00     0.00
## evaluate                  2.28    100.00      0.00     0.00
## evaluate_call             2.28    100.00      0.00     0.00
## handle                    2.28    100.00      0.00     0.00
## in_dir                    2.28    100.00      0.00     0.00
## knit                      2.28    100.00      0.00     0.00
## process_file              2.28    100.00      0.00     0.00
## process_group.block       2.28    100.00      0.00     0.00
## try                       2.28    100.00      0.00     0.00
## tryCatch                  2.28    100.00      0.00     0.00
## tryCatchList              2.28    100.00      0.00     0.00
## tryCatchOne               2.28    100.00      0.00     0.00
## withCallingHandlers       2.28    100.00      0.00     0.00
## withVisible               2.28    100.00      0.00     0.00
## rbind.fill                1.26     55.26      1.16    50.88
## read.table                0.98     42.98      0.02     0.88
## read.csv                  0.98     42.98      0.00     0.00
## scan                      0.92     40.35      0.92    40.35
## quickdf                   0.04      1.75      0.04     1.75
## seq                       0.04      1.75      0.04     1.75
## sapply                    0.04      1.75      0.00     0.00
## simplify2array            0.04      1.75      0.00     0.00
## unique.default            0.02      0.88      0.02     0.88
## unlist                    0.02      0.88      0.02     0.88
## [[                        0.02      0.88      0.00     0.00
## [[.data.frame             0.02      0.88      0.00     0.00
## unique                    0.02      0.88      0.00     0.00
## 
## $sampling.time
## [1] 2.28
</code></pre>

<p>The code is still very clean, we basically just replaced one line.  For the case of only looking at the first 100 files it appears to be a little slower.  Let&#39;s try each method on a larger set.  We should also check that everything is working as we expect it to.</p>

<pre><code class="r"># Time the first 200
files &lt;- fileList[1:200]

# Run a side by side comparison of each method.
benchmark(replications = rep(1, 1), M1(), M2(), M3(), M4(), columns = c(&quot;test&quot;, 
    &quot;replications&quot;, &quot;elapsed&quot;))
</code></pre>

<pre><code>##   test replications elapsed
## 1 M1()            1   19.73
## 2 M2()            1   14.32
## 3 M3()            1    4.01
## 4 M4()            1    3.95
</code></pre>

<pre><code class="r">
# Check that each method works.
all(all(games1 == games2, na.rm = TRUE), all(games2 == games3, na.rm = TRUE), 
    all(games3 == games4, na.rm = TRUE))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Thinking through what is happening here leaves me to wonder if all of these methods are bad.  In the cases where we use indexing we are getting beat up by the copy on modify, every time we add new rows we copy the whole data frame due to immutability.  The naive rbind approach is always looking for larger sections of contiguous memory.  Thus in the beginning it is small copying every increasing sets around just keeps building up though.  The do.call and rbind.fill method seem to be very close to pre-allocation time, I want to see what they are doing under the hood though before I say anything about them.  I would imagine that a divide and conquer approach would work here.  We can use the naive rbind but never have to carry the whole data frame, actually only half one time, a quarter twice, etc., which is why its so slow.</p>

<pre><code class="r"># Recursive row binding, you don&#39;t carry huge sets around, has divide and
# conquer on memory usage, large set only appear at the top level of the
# recursion.
recurBind &lt;- function(dList) {
    len &lt;- length(dList)/2
    # Preallocate list for small improvement.
    data &lt;- vector(&quot;list&quot;, len)
    j &lt;- 1
    for (i in seq(len)) {
        # Merge each set of two sequential data sets together.
        data[[j]] &lt;- rbind(dList[[(i * 2) - 1]], dList[[i * 2]])
        j &lt;- j + 1
    }
    # In case length was odd, just add last set to the end.
    if (floor(len) != len) {
        data[[j]] &lt;- dList[[len * 2]]
    }
    # Recursive call.
    if (length(data) &gt; 1) {
        data &lt;- recurBind(data)
    }
    return(data)
}

# Apply the recursive method.
M5 &lt;- function() {
    # Initialize list that will store each loaded file.
    g &lt;- vector(&quot;list&quot;, length(files))
    # Initialize the index.
    j &lt;- 1
    # Loop over all of the files.
    for (i in files) {
        g[[j]] &lt;- read.csv(i, na.strings = &quot;&quot;)
        j &lt;- j + 1
    }
    games &lt;- recurBind(g)[[1]]
    return(games)
}
files &lt;- fileList[1:100]
Rprof(&quot;recursive.out&quot;)
games5 &lt;- M5()
Rprof(NULL)
summaryRprof(&quot;recursive.out&quot;)[c(2, 4)]
</code></pre>

<pre><code>## $by.total
##                     total.time total.pct self.time self.pct
## &lt;Anonymous&gt;               1.60    100.00      0.00     0.00
## block_exec                1.60    100.00      0.00     0.00
## call_block                1.60    100.00      0.00     0.00
## evaluate                  1.60    100.00      0.00     0.00
## evaluate_call             1.60    100.00      0.00     0.00
## in_dir                    1.60    100.00      0.00     0.00
## knit                      1.60    100.00      0.00     0.00
## process_file              1.60    100.00      0.00     0.00
## process_group.block       1.60    100.00      0.00     0.00
## withCallingHandlers       1.60    100.00      0.00     0.00
## doTryCatch                1.58     98.75      0.00     0.00
## eval                      1.58     98.75      0.00     0.00
## handle                    1.58     98.75      0.00     0.00
## M5                        1.58     98.75      0.00     0.00
## try                       1.58     98.75      0.00     0.00
## tryCatch                  1.58     98.75      0.00     0.00
## tryCatchList              1.58     98.75      0.00     0.00
## tryCatchOne               1.58     98.75      0.00     0.00
## withVisible               1.58     98.75      0.00     0.00
## read.table                1.00     62.50      0.02     1.25
## read.csv                  1.00     62.50      0.00     0.00
## scan                      0.90     56.25      0.90    56.25
## rbind                     0.58     36.25      0.40    25.00
## recurBind                 0.58     36.25      0.00     0.00
## levels                    0.08      5.00      0.08     5.00
## type.convert              0.06      3.75      0.06     3.75
## [[.data.frame             0.06      3.75      0.02     1.25
## [[                        0.06      3.75      0.00     0.00
## match                     0.04      2.50      0.02     1.25
## %in%                      0.04      2.50      0.00     0.00
## is.empty                  0.02      1.25      0.02     1.25
## is.ordered                0.02      1.25      0.02     1.25
## Make.row.names            0.02      1.25      0.02     1.25
## sys.call                  0.02      1.25      0.02     1.25
## unlist                    0.02      1.25      0.02     1.25
## handle_output             0.02      1.25      0.00     0.00
## plot_snapshot             0.02      1.25      0.00     0.00
## sapply                    0.02      1.25      0.00     0.00
## simplify2array            0.02      1.25      0.00     0.00
## 
## $sampling.time
## [1] 1.6
</code></pre>

<p>It&#39;s faster than all the other methods, but I was actually thinking that it would be slower for this small case and would only be asymptotically faster once we take the rest of the files into consideration.  Let&#39;s run the above test again and see how good it fares.</p>

<pre><code class="r"># Time the first 500
files &lt;- fileList[1:500]

# Run a side by side comparison of each method.
benchmark(replications = rep(1, 1), M1(), M2(), M3(), M4(), M5(), columns = c(&quot;test&quot;, 
    &quot;replications&quot;, &quot;elapsed&quot;))
</code></pre>

<pre><code>##   test replications elapsed
## 1 M1()            1  110.24
## 2 M2()            1   83.16
## 3 M3()            1   16.34
## 4 M4()            1   16.05
## 5 M5()            1   10.64
</code></pre>

<pre><code class="r">
# Check that each method works.
all(all(games1 == games2, na.rm = TRUE), all(games2 == games3, na.rm = TRUE), 
    all(games3 == games4, na.rm = TRUE), all(games4 == games5, na.rm = TRUE))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>It seems I was right. The first two methods are performing very poorly.  We can safely ignore them from here on out.  How do the remaining methods fair against the whole collection of files.</p>

<pre><code class="r"># Time whole set
files &lt;- fileList
benchmark(replications = rep(1, 1), M3(), M4(), M5(), columns = c(&quot;test&quot;, &quot;replications&quot;, 
    &quot;elapsed&quot;))
</code></pre>

<pre><code>##   test replications elapsed
## 1 M3()            1   83.21
## 2 M4()            1   97.55
## 3 M5()            1   26.69
</code></pre>

<p>I don&#39;t think we have got all we can out of the recursive method either.  R deals with recursion by adding the environment to the call stack.  In a normal function you dont worry about cleaning the local environment before you leave it because it will be destroyed when only moving the return object.  In the case of recursion though we add the whole environment to the stack then jump to the next iteration.  Do to the log nature of the divide and conquer we don&#39;t have to worry about going infinitely deep but we do have to worry about copying a lot of useless data at every new level of depth.  Lets clean the environment except what we actually care about.</p>

<pre><code class="r">recurBind2 &lt;- function(dList) {
    len &lt;- length(dList)/2
    # Preallocate list for small improvement.
    data &lt;- vector(&quot;list&quot;, len)
    j &lt;- 1
    for (i in seq(len)) {
        # Merge each set of two sequential data sets together.
        data[[j]] &lt;- rbind(dList[[(i * 2) - 1]], dList[[i * 2]])
        j &lt;- j + 1
    }
    # In case length was odd, just add last set to the end.
    if (floor(len) != len) {
        data[[j]] &lt;- dList[[len * 2]]
    }
    # Less data to store on the stack, tail call optimization would be nice
    # here.  Try removing this and check out the time diff.
    rm(dList, len, j)
    # Recursive call.
    if (length(data) &gt; 1) {
        data &lt;- recurBind(data)
    }
    return(data)
}
# Apply the recursive method.

M6 &lt;- function() {
    # Initialize list that will store each loaded file.
    g &lt;- vector(&quot;list&quot;, length(files))
    # Initialize the index.
    j &lt;- 1
    # Loop over all of the files.
    for (i in files) {
        g[[j]] &lt;- read.csv(i, na.strings = &quot;&quot;)
        j &lt;- j + 1
    }
    games &lt;- recurBind2(g)[[1]]
    return(games)
}
files &lt;- fileList[1:100]
Rprof(&quot;recur2.out&quot;)
games6 &lt;- M6()
Rprof(NULL)
summaryRprof(&quot;recur2.out&quot;)[c(2, 4)]
</code></pre>

<pre><code>## $by.total
##                     total.time total.pct self.time self.pct
## &lt;Anonymous&gt;               2.00       100      0.02        1
## block_exec                2.00       100      0.00        0
## call_block                2.00       100      0.00        0
## evaluate                  2.00       100      0.00        0
## evaluate_call             2.00       100      0.00        0
## in_dir                    2.00       100      0.00        0
## knit                      2.00       100      0.00        0
## process_file              2.00       100      0.00        0
## process_group.block       2.00       100      0.00        0
## withCallingHandlers       2.00       100      0.00        0
## doTryCatch                1.98        99      0.00        0
## eval                      1.98        99      0.00        0
## handle                    1.98        99      0.00        0
## M6                        1.98        99      0.00        0
## try                       1.98        99      0.00        0
## tryCatch                  1.98        99      0.00        0
## tryCatchList              1.98        99      0.00        0
## tryCatchOne               1.98        99      0.00        0
## withVisible               1.98        99      0.00        0
## read.table                1.46        73      0.36       18
## read.csv                  1.46        73      0.00        0
## scan                      1.06        53      1.06       53
## recurBind2                0.52        26      0.00        0
## rbind                     0.50        25      0.34       17
## recurBind                 0.38        19      0.02        1
## levels                    0.06         3      0.06        3
## [[.data.frame             0.04         2      0.02        1
## [[                        0.04         2      0.00        0
## close.connection          0.02         1      0.02        1
## FUN                       0.02         1      0.02        1
## is.factor                 0.02         1      0.02        1
## is.ordered                0.02         1      0.02        1
## R.Version                 0.02         1      0.02        1
## type.convert              0.02         1      0.02        1
## close                     0.02         1      0.00        0
## handle_output             0.02         1      0.00        0
## paste                     0.02         1      0.00        0
## plot_snapshot             0.02         1      0.00        0
## recordPlot                0.02         1      0.00        0
## rversion                  0.02         1      0.00        0
## vapply                    0.02         1      0.00        0
## 
## $sampling.time
## [1] 2
</code></pre>

<p>This should be better, try it on the larger test.</p>

<pre><code class="r"># Time whole set
files &lt;- fileList
benchmark(replications = rep(1, 1), M3(), M4(), M5(), M6(), columns = c(&quot;test&quot;, 
    &quot;replications&quot;, &quot;elapsed&quot;))
</code></pre>

<pre><code>##   test replications elapsed
## 1 M3()            1   80.68
## 2 M4()            1   88.42
## 3 M5()            1   24.69
## 4 M6()            1   21.81
</code></pre>

<p>To me this is a very interesting result; we used in what is reality the slowest approach possible, rbind, in a clever manner to get the fastest approach. What if we apply some of the faster methods inside the recursion, or even get rid of the recursion altogether by smart looping in a manner that is equivalent to recursion but never has to recreate the local environment recursively.  Is there a way that we can mimic tail call optimization or even compile this?  I am sure there are even faster ways of doing this.  What was all of this for again, oh yeah Basketball.</p>

<pre><code class="r">files &lt;- fileList
games &lt;- M6()
made &lt;- games[, c(&quot;team&quot;, &quot;player&quot;, &quot;etype&quot;, &quot;result&quot;, &quot;x&quot;, &quot;y&quot;)]
made &lt;- made[made$etype == &quot;shot&quot;, ]
made &lt;- made[made$result == &quot;made&quot;, ]
made &lt;- made[, c(&quot;result&quot;, &quot;x&quot;, &quot;y&quot;)]
made &lt;- made[complete.cases(made), ]
made$result &lt;- ifelse(made$result == &quot;made&quot;, 1, 0)
x &lt;- tapply(made$result, made[, c(&quot;x&quot;, &quot;y&quot;)], sum)
x &lt;- ifelse(is.na(x), 0, x)
image(log(x), col = rainbow(30))
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk basketball"/> </p>

<pre><code class="r">
missed &lt;- games[, c(&quot;team&quot;, &quot;player&quot;, &quot;etype&quot;, &quot;result&quot;, &quot;x&quot;, &quot;y&quot;)]
missed &lt;- missed[missed$etype == &quot;shot&quot;, ]
missed &lt;- missed[missed$result == &quot;missed&quot;, ]
missed &lt;- missed[, c(&quot;result&quot;, &quot;x&quot;, &quot;y&quot;)]
missed &lt;- missed[complete.cases(missed), ]
missed$result &lt;- ifelse(missed$result == &quot;missed&quot;, 1, 0)
y &lt;- tapply(missed$result, missed[, c(&quot;x&quot;, &quot;y&quot;)], sum)
y &lt;- ifelse(is.na(y), 0, x)
image(log(y), col = rainbow(30))
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAApVBMVEX9/v0AAAAAADkAAGUAM/8AOTkAOY8AZrUAZv8Amf8AzP8A/wAA/zMA/2YA/5kA/8wA//8z/wA5AAA5ADk5AGU5OWU5OY85j9plAABlADllAGVlOQBlOY9ltf1m/wCPOQCPOTmPZgCPtY+P29qP2/2Z/wC1ZgC1/v3M/wDajzna24/a/v39tWX924/9/rX9/tr9/v3/AAD/ADP/ZgD/mQD/zAD//wCVwlNqAAAAN3RSTlP///////////////////////////////////////////////////////////////8A////////r204NgAAAAlwSFlzAAALEgAACxIB0t1+/AAAEtBJREFUeJztneti28YRRqsktVNfEttNI8WtrbT1TbVujmO9/6PVpHYs8hOGuwssSABzzh8bEDDY3TMghwuQ+Ms1hOQvh24AHAbEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAflLz4ixdHK75/v4fWwN7Iir86fbX+9/zBx9EbA/sjK/7y5futf2EZcMYHJf8ef3nCe/wCGVLVH8GUGVH8gH1hbFqJ3yjuCnMKDgpnfFAQHxTEBwXxQRkqPn2M7/ogj/gpM/iMvzo97hcaDsrwl/rL3970Cg0Hhff4oCA+KIgPCuKDgvigID4oiN/Fp8Sh2zECiN8F4kcIPQcQP0LoOYD4EUIPY8FKrvfSNcRPD8TvAPEDQfz0QPyKz4kmweAbiA8K4oOC+KBMXnwhXxL7POasQXxQEB8UxAcF8UGZnPhcFU+R3wbEBwXxQUF8UCYnPsfNLaPEjgTig4L4oCA+KLMTP2XmNIuE+IYgviT0AkF8SegFgviS0FPmScKWHycO2abGIL4LxCN+DeIbhp4yiA8q/nliv0e96Z6cGuc+Y8R3gXjE7xHEHxzET0+8o+RpojBKZqrlQ0IOuudEyDAsHxDfBeIRv3lQxLcI3RPEG8HEO6j4nxJp0cy9TRRGfZ2wZQsz7nyOzB7ZbFLb7EP8LhA/Qui2IL4SxO8C8SOEboteVimkMBGeC31beYumk5IKz9xmw0A84rtA/BrENwzdFsRXgnjEdzEd8W1/w9QuhFWKb3PwwqiF4ivnLA3EI76LvPiLF0cPz7qeKYz4HLMWf/X7m+uzh1/9//qxMnQliHc4kPjLl++vz45v/60Lbfx5S9nGfZGJvFqcu2x7VpQabVha9dz78Gc84mcpfvUefzzoPR7x8xTfO7SB+KDi27CfXzcvNL3XL970zL5W4jeKuyOjsimDQHzlbpzxNSC+Qei2IL5ytxZV/YrmM3fjXqKopOfgCpVlmG0+zkgM/hx/+mr97/mDxjN3iJ+2eCvq+s/cOSB+2uI548tZlPjry5M27/GV978OpPDKho39QPFT/D2NyVT1iN8viN8F4kcILSB+vxxevDOm+oVVXd4L+81G48k2+mcp9nrOFiF+F4jvA+J7gnjEL1l8hr1e8GhEYemoabXXNEP8CCC+AYgfB8SPAOLHRy982M9ZDcsXnbgZWFlKlaZVm1PFaR5UNiJzbQfxu6Iivg+INxDfHsR7IH5AVMT3oVC80z4b+0KDhXe3aL3t/LRp5T27lbfWFDLu5xnEI74LxJeA+JrQBuIdgoi3wbOaJDON5V266klGXWXJOPC+WNl7onfZ9g5tIN7ZvVE0B8SvQbyA+DWIbxhayI2pdN82z9VV/X4SyqJXzpn82fTXPXJdG1ZRIn5XYxA/QmgB8Qri1yDe+XvP6JMR7zHO5EglPROhJ06y6kggfnwQ3zB0IYg3EL9/EN8wtIPNzHjFnlPU6XxPm3yxqM4DvkvZ/TzTHDpX5UzoVM7zIH4XiO8D4g3EF4B4JYj4HJl5HqNQfOZaT+k0kUPlhI6pSwezg3unwsKKuxyIt80R3wXiMyAe8V0cTvzPiWeJQcFcnBLSqyx7kh6g5eXBjSC3pnhRET8AxDsgvgWIrwDxiEd8JwsTr991sWV5gFjhr43k7sDJDK5X9Le5xdf5Go8lgrdbz48YAuIR3wXiEd86tAPig4pXngrOZpXPEC3MmydCRbt3RLO61dsuVZbWJe+y28KKOwXxiEf8FohfgfhKJideleiYd9d6jXks9AwjaaPRvOyTW3ltM53KknyoTE7Ed4F4xCO+GsQjvgKdnsjUV153f0z8cIutfpTI7V528J4URrPctq/v6DWelAc953MQj/guSp4f/+rq9Ojo/jOFEe+xCPGrp0m/e/XV/6+NniaNeGPa4i9fvr/6/c0Iz4/PUPm9EcuDPxK2PnObhzeohTVfxrBX3MkETu4o/Rj8Uv/1dD8/vr4+f1gbehiIH8jw4u7d+vnx970jfuHi+4YeBuIHMnnxVtqI6Q+C7ia/P22Fkacid91EwmQ2K8xKb3rIWd22wmwlfqO4OzL6t2oDxBvTFF8fuhDEG4jfXI34njSYuVu/rH9/72P8QPH27QLnjsTcb1RUPmNCsF/CGBYlR+HvbFiF6eW4bFZ48BYzdyvO78/ZIj7DrMVbUdd85g7xxjTFc8b3Z9biry9Per7Hy6B+cXC6myuzJHr62uKnbHe6Gbh7IdZV+Y6l5YdmoYyA9/UMh8NV9YhXEI94xCMe8Vsgfrbi58R+xBdiCSFtqmwj4ktAfA2IHwfE7w/E1zBM/KTGeoEgPiiIDwrigzJZ8XNkTsmK+IYgviT0AkF8SegFgviS0AdhTmrGBfFBQXxQEB+UYOLBQHxQEB8UxAcF8UslU8cifqkgPiiID8pcxQeaajlIVxF/eBC/CeLHBfGHB/GwPxAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBA/PfZysQ7x0wPxQUF8UBAP44H4oCA+KIgPyoji49wmO0cQHxTEBwXxQaG4C0ob8Re/3H/CKOInzeCnSd8+Wrbr4bKInzINHir8VTln/Oxo8FJ/efLgf4ivoNG3Y4dFafIef/Gi4yniiPdYjvheoeOC+KAsSvzly28v9kdGzyYdkilNOo37Qxmc8VsgPoH4wzFx8RcvnPkbxA9k2uKvTl+t/z1/8LEy9CRBfCI/ZZuKuo3irjB0WypHadxBnQNLOeMRX0mDufpJvMcjvpKlVPWIr2Q24h1VOYPhBXsgPiiIDwrigzJZ8Z8EW//5Ft3Mlv9MFEbr2aieu08JxPdpVM/dpwTi+zSq5+5TAvF9GtVz9ykxGfE6pracRH82o2nxS+JG+JCwv3/exlZrdMNp1IKEG4hHfBeIR3zr0ALi98tkxCtq9m0iiZXFbzzv5nXiraB5ImheSL7k8mHK+YJ4xHeBeMS3Dp0B8eNyePFpEE2wrVajgpo0w48TT3Zjm1kYXZboevS02vLDCk8VLfliqyeRD4hHfBeIR3zr0AbiD8LhxSdsjHUmxtabiyRYDT6X9cJT4aeELWs4SR9Z/ViyzCsdrS8pPyYh3EA84rtAPOJbhxYQv18mI16vtohordrUmJp1lGkxp3mTQaLqwZ2ss821VJS8+GJD0X3BqDGIR3wXiEd869AC4hGP+EWLd6a1bBRslDLitTw3Hm8Pts6x6ZjLhKAd1CvTZbZRk/WxkxhOcurRZJrQu0Q4QE3eDuIR3zo04hGP+EjiHVSJkwAqXhNABlOjiWgPzTpbn6LYorX5rRzNSH+2g1pUTQBZ1srSosu1wHHsIB7xrUM7IB7xiI8k3rDuafmVRsEGy4T/nLBlKe5sb00jXRbhKv7JNrZaN3fS6K1gjbIu2nYpqua05vZ2D79lWxs7iEd8NYhHfA8QH1S8TlPYKKVCycZYE0BHJ42Kll+qyuGxw9NudDcnqgnWzWW9Ld5Il526VrNxmB3EI74axCO+B4hfmnjnd6k8PgndtZ6bAGm11ldSR5XiFHey+onnQvLBqxFlc60RbbMP2+jBLT/q7BiIR3w1iEf8JogPKt4aKFdj7M+FtxnYXQk2bZFJABtEzRfdzcEp5hyx3g0Y3uZe/pSlmeaDTg/V2TEQj/hqEI/4TRAfXLxTflXWfobli3XXRknG3lbrdREp9jzhjgoPyS41523uFJ5OInj5oVHL7BiIR3w1iEf8JogPJl4bJDcQ2Njq5EdhQjjzPHZ3pRq0RugFkEytJ43z8iKTB7peG5XQqk2RRnjJauF221GKnh//3ZuSp0kjflHiV0+Tvjo9Rnw08bfC3z1EfDDx6fnxZ3/9BfGhxF9fnhyvzd9/gLyEzoyOleNmTC86yW6lxX+a4LNB1NGxZTua3KCjm//UjY61RhfhjsEncjQvAZwwtjrT5mbifRCP+BWIX6T4jeLuyEB8APEdSGine4p2S2pAm2vTsbUqLXNxTy/mSfbZjJ5d+7PNvLzJCBf0upneDiSoSR2RDLr7bjsK4hHvcPFi/bJ+v6hH/KLFp8/x1+cPPiI+kngr6vyZO6lBvG+e5gZPomg+WFTb3f7u5IGZ1QmcdDCtNC2aky8Z4R6aVpII1ggdQNvdyRfbzZZl71bi82c84hcp/vryJPMej/hlivdBfGzxhnZTyOSFN2gyWPd+gCopsc3NpJcIKYqZlJrvXgKICk0ECaObeaeEM1DO5s6ZcW9kdttBPOIRj3jEI75evLbbWdZ2FibCUzGrR0mVjrVJR8mZ99GS0bjZpmebVbxzKnjCZb22UY9im6e2Ih7xiEc84hHfTLy2WxtaOAqynS2aeE0EDZvQ6yO2bJtLnlg+mGkZTLsbROdMtM1OHjhtzJ0KXkI442xH67aDeMQjHvGIR3x/8fa70qookwDa/kw3ve5mxtoG8cM2kgcf9PaOpMQ2s7zQtJJGeY3xClRHdEa8DqicEohHPOIRj3jEIx7xw8Rbt+yrHM8SkghOHtxLiMKSV7qto6DRX2+H1ak53Sz10PJBN/sivN3GUySNfF1G5SmAeMQjHvGIR3xz8XZkSwAr+lIeeN9A1fZLtFy3d4/CvW/NSpYZmghSjVmPbSZPs09qP0PVOcmqqS+UJkSKgnjEIx7xiEd8c/E6xrb88zbPnETIGBNz3ijpYCqZMTfxMlGjSWpFnyVC2ts2uxG8BHAa4eR8pksG4hGPeMQjHvGjifcSQDDhOt9TiCaCDF7hKHlplTBjVq1ZdGu7bSfzObaZJoL8vTAfvPxwdkM84hGPeMQjvpl4HTQ160zceJulGlA31zTywiUKhXuNcbLMxtqKPlsvt6KYYPuKrjXCojvppCZlXHWcdRZJNkM84hGPeMQjfrB4b4w1ERyDOubPtnmUsGWbBxKDnmBtXCFOHnjRpZjTelUv3shmrwWnL9oIZ7zFDuIRj3jEIx7x/cXnxjqNim7m7ZYWTfDfEj8mfkjYcsoLU2TRnEIpc1Btu26uyeokxHPp8iNpZPJvl3g0X6TW89qqB++2g/iSgyIe8YhH/B2I7xKfGUTrh16a0PWC/dkGzQbRxP9xiy3a4KkD/a6DoI3MJICRme/RkZA+WG7beNq1HAuTNrO9M7Uf4hGPeMQjHvGIR3wb8c5Y6qBau236SpcFG4XPDlYSS68fyaDaKFnYtJlGsaPZZunymuz1DU1WJ8e9tEpRzZglq+WFHSXlqqa8l6TddjwQj/hqEI94xAcUL+18q6MlJu32FG85qfCE6+9TCZ4qa9yA7m5wIziN0BGRClNz3JDCVA9qtZ/lttNlxG81bkB3N0D8JojXRsxbfPFjxBGvjZi1+PLHiJsa+VqJPQnMFq2dVlfpcq5BiUwCKNa4ws0rcYJb15y2Wpu8ZE0DZhWkc9Bvj0KXP4//GHFtCOKNWYvnjC+PrqtnLT7/GHFtCOKNeYv3yYQupNLgAqlM+UIQP3mmLX6juDsy+rdqA8RPW3x96EIQPz/xMGWGivdn7q5bnfSjRozYxIKAQz7Hlx2hkumP6gya2EL8jpm7siNUMv1RnUETOePHCDiDJrYQv2PmruwIlUx/VGfQxCbihx7h0BEjNhHxYwScQRPHFw9zBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQekp/vLkKF2tu/vfMO7irO78eNUy4N0lxlYRr06PvnvTMuDXPndfBavl4pf3Etqhn/jVQJ493P7fMO7iXP725vri74OHdathZy0yaSPiu1fOZeqeAVd9Pmtx/pyn/Mlr6Sd+dVfGbW7d/W8Yd3HOV+19N1jUZsMu/vHPFi8hW51uwF3Ai18/Ngn67rv/3HY5r6Wf+HVDf3uz9b9hbMdpEHEj4NXv/23xUr/Z6X+3eKm/C9jsjDfbeS39xK9e527j3v1vGFtxrk6PWwY8O27yHn8X8eLFq/XQNgvYrFIy8XktUzzjL0+Ge99uYhPxzTu9EfBrTXPepLob+Ywf8z1+fT4N5y7g2frWseG5tNHpfzURv1HXNHrd/CZ+rPf41WuxVfXHjap6i9PG+3bDmpzxGxHfNXmp3+hz6zM+r2XQ5/jVUdp+jv8a8fYEHS7qroltP8enTrfQdBfw/KjJxMCt+CItzNwFBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UBAfFMQHBfFBQXxQEB8UxAcF8UFBfFAQHxTEBwXxQUF8UP4PAO2HOoWJuAYAAAAASUVORK5CYII=" alt="plot of chunk basketball"/> </p>

<p>Just to check how good this is lets run a few years.  This adds the prior two seasons.</p>

<pre><code class="r">
# Data for the year prior.
url2 &lt;- &quot;http://www.basketballgeek.com/downloads/2007-2008.regular_season.zip&quot;

# Take the base of the file name at this loaction.
file2 &lt;- basename(url2)

# Download the file from the internet.
download.file(url2, file2)

# Extract zipped contents to directory.
unzip(file2, exdir = dir)

# The list of unzipped files.
newList &lt;- list.files(dir)

# Only the csv data files.
newList &lt;- newList[grep(pattern = &quot;csv&quot;, x = newList)]

# Full location to the files.
newList &lt;- paste(dir, newList, sep = &quot;/&quot;)

length(fileList)
</code></pre>

<pre><code>## [1] 1176
</code></pre>

<pre><code class="r">length(newList)
</code></pre>

<pre><code>## [1] 2359
</code></pre>

<pre><code class="r">
# Time larger set
files &lt;- newList
system.time(games1 &lt;- M3())[3]
</code></pre>

<pre><code>## elapsed 
##   329.2
</code></pre>

<pre><code class="r">system.time(games1 &lt;- M4())[3]
</code></pre>

<pre><code>## elapsed 
##   533.8
</code></pre>

<pre><code class="r">system.time(games1 &lt;- M5())[3]
</code></pre>

<pre><code>## elapsed 
##   67.11
</code></pre>

<pre><code class="r">system.time(games1 &lt;- M6())[3]
</code></pre>

<pre><code>## elapsed 
##   60.39
</code></pre>

<pre><code class="r">
</code></pre>

</body>

</html>

